# NixOS Configuration Implementation Plan
## Flake-Parts + Niri + NVIDIA + AMD Ryzen 7 5800X

---

## Document Information

**Last Updated**: October 2025
**Target NixOS Version**: 24.05+ (unstable recommended for latest features)
**Niri Version**: Latest stable and unstable via [sodiboo/niri-flake](https://github.com/sodiboo/niri-flake)

### Important Version Notes

- **NixOS 24.05+**: `hardware.opengl` was renamed to `hardware.graphics`
- **Niri Flake**: Actively maintained with automatic updates for niri-unstable
- **Binary Cache**: Available at `niri.cachix.org` for x86_64-linux
- **Kernel**: 6.1+ recommended for AMD P-State driver support

### Key Resources

- [NixOS Options Search](https://search.nixos.org/options)
- [Niri Flake Documentation](https://github.com/sodiboo/niri-flake/blob/main/docs.md)
- [Niri Wiki](https://github.com/YaLTeR/niri/wiki)
- [NVIDIA NixOS Wiki](https://nixos.wiki/wiki/Nvidia)

---

## Overview
This plan outlines the complete setup for a NixOS system using:
- **Flake Framework**: flake-parts for modular organization
- **Compositor**: niri (scrollable-tiling Wayland compositor)
- **GPU**: NVIDIA with Wayland support
- **CPU**: AMD Ryzen 7 5800X optimization

---

## 1. Initial Flake Structure with Flake-Parts

### 1.1 Core Files - Flat Import Pattern
```
NixOS/
├── flake.nix                 # Main flake entry point - ALL imports happen here
├── flake.lock                # Auto-generated lock file
│
├── flake-parts/              # Flake-parts modules (imported in flake.nix)
│   ├── packages.nix          # Custom package definitions
│   ├── overlays.nix          # Nixpkgs overlays
│   ├── devshells.nix         # Development environments
│   └── checks.nix            # Build checks (optional)
│
├── nixos/                    # NixOS system modules (flat structure)
│   ├── hardware.nix          # AMD Ryzen 7 5800X configuration
│   ├── nvidia.nix            # NVIDIA driver configuration
│   ├── desktop.nix           # Desktop environment (niri + XDG portals)
│   ├── boot.nix              # Bootloader configuration
│   ├── networking.nix        # Network configuration
│   ├── locale.nix            # Locale, timezone, console
│   ├── users.nix             # User accounts
│   ├── audio.nix             # PipeWire audio
│   ├── packages.nix          # System-wide packages
│   └── nix-settings.nix      # Nix daemon settings, binary caches
│
├── hosts/
│   └── <hostname>/
│       ├── configuration.nix # Host-specific settings (hostname, etc.)
│       └── hardware-configuration.nix  # Generated by nixos-generate-config
│
└── home/
    └── <username>/
        ├── home.nix          # Home-manager base configuration
        ├── niri.nix          # Niri user configuration
        ├── shell.nix         # Shell configuration (bash/zsh/fish)
        ├── git.nix           # Git configuration
        └── packages.nix      # User packages
```

**Key Principles**:
1. All NixOS modules are imported directly in `flake.nix` modules list
2. All flake-parts modules are imported in `flake.nix` imports list
3. Individual module files do NOT import other modules
4. This creates a flat, explicit import hierarchy with maximum depth of 1

### 1.2 Flake Inputs Required
- `nixpkgs`: Main package repository
- `flake-parts`: Modular flake framework
- `home-manager`: User environment management
- `niri-flake`: Niri compositor with NixOS module (from sodiboo/niri-flake)

### 1.3 Flake Outputs Structure
Using flake-parts, organize outputs as:
- `nixosConfigurations.<hostname>`: System configurations
- `homeConfigurations.<username>`: Home-manager configurations (optional, if using standalone)
- `packages.<system>.<name>`: Custom packages (defined in flake-parts modules)
- `overlays.<name>`: Nixpkgs overlays (defined in flake-parts modules)
- `devShells.<system>.<name>`: Development environments (defined in flake-parts modules)
- `formatter.<system>`: Nix code formatter (nixpkgs-fmt or alejandra)

### 1.4 Flat Import Pattern in flake.nix
**All modules are imported in a single list in flake.nix:**
```nix
nixosConfigurations.<hostname> = nixpkgs.lib.nixosSystem {
  modules = [
    # Host configuration
    ./hosts/<hostname>/configuration.nix
    ./hosts/<hostname>/hardware-configuration.nix

    # NixOS modules (all imported directly, no nested imports)
    ./nixos/hardware.nix
    ./nixos/nvidia.nix
    ./nixos/desktop.nix
    ./nixos/boot.nix
    ./nixos/networking.nix
    ./nixos/locale.nix
    ./nixos/users.nix
    ./nixos/audio.nix
    ./nixos/packages.nix
    ./nixos/nix-settings.nix

    # External modules
    niri-flake.nixosModules.niri
    home-manager.nixosModules.home-manager

    # Home-manager configuration
    {
      home-manager.users.<username> = {
        imports = [
          ./home/<username>/home.nix
          ./home/<username>/niri.nix
          ./home/<username>/shell.nix
          ./home/<username>/git.nix
          ./home/<username>/packages.nix
        ];
      };
    }
  ];
};
```

**Benefits of this pattern:**
- **Explicit**: All imports visible in one place
- **No hidden dependencies**: Clear what's being loaded
- **Easy to enable/disable**: Comment out a single line
- **Better error messages**: Easier to identify which module has issues
- **Simpler debugging**: No need to trace nested imports

### 1.5 Flake-Parts Module Pattern
**Custom packages and overlays are defined as flake-parts modules:**

```nix
# In flake.nix
flake-parts.lib.mkFlake { inherit inputs; } {
  systems = [ "x86_64-linux" ];

  # Import flake-parts modules
  imports = [
    ./flake-parts/packages.nix   # Custom packages
    ./flake-parts/overlays.nix   # Nixpkgs overlays
    ./flake-parts/devshells.nix  # Development shells
  ];

  # ... rest of configuration
}
```

**Example flake-parts module (flake-parts/packages.nix):**
```nix
{ inputs, ... }:

{
  perSystem = { config, self', inputs', pkgs, system, lib, ... }: {
    packages = {
      my-custom-package = pkgs.stdenv.mkDerivation {
        pname = "my-custom-package";
        version = "1.0.0";
        # ... package definition
      };
    };
  };
}
```

**Benefits of flake-parts modules:**
- **Modular**: Separate concerns (packages, overlays, dev shells)
- **Reusable**: Can be shared across different flakes
- **Clean**: Keeps flake.nix focused on structure
- **Organized**: Each type of output in its own file
- **Scalable**: Easy to add new packages without cluttering flake.nix

---

## 2. Hardware Configuration - AMD Ryzen 7 5800X

### 2.1 CPU-Specific Optimizations
**NixOS Options to Configure:**
- `hardware.cpu.amd.updateMicrocode = true;`
  - Enable AMD microcode updates for security and stability

- `boot.kernelModules = [ "kvm-amd" ];`
  - Enable AMD virtualization support

- `nixpkgs.hostPlatform = "x86_64-linux";`
  - Set correct architecture

### 2.2 CPU Governor and Performance
- `powerManagement.cpuFreqGovernor = "schedutil";` or `"performance"`
  - schedutil: Balanced performance/power
  - performance: Maximum performance (higher power consumption)

### 2.3 Kernel Parameters
- `boot.kernelParams`:
  - `"amd_pstate=active"` - Use AMD P-State driver (kernel 6.1+)
  - `"processor.max_cstate=1"` - Reduce latency (optional, for gaming/low-latency)

### 2.4 Additional Hardware Support
- `hardware.enableRedistributableFirmware = true;`
- `hardware.enableAllFirmware = true;` (if needed for peripherals)

---

## 3. NVIDIA Driver Configuration with Wayland Support

### 3.1 Core NVIDIA Options
**Primary Configuration (`modules/nixos/nvidia.nix`):**

```nix
hardware.nvidia = {
  modesetting.enable = true;           # REQUIRED for Wayland
  powerManagement.enable = false;      # Experimental, can cause issues
  powerManagement.finegrained = false; # For laptops with hybrid graphics
  open = false;                        # Use proprietary driver (open is beta)
  nvidiaSettings = true;               # Include nvidia-settings GUI
  package = config.boot.kernelPackages.nvidiaPackages.stable;
};
```

### 3.2 Kernel Parameters for NVIDIA + Wayland
**Add to `boot.kernelParams`:**
- `"nvidia-drm.modeset=1"` - **CRITICAL** for Wayland support
- `"nvidia-drm.fbdev=1"` - Enable framebuffer device (kernel 6.6+)
- `"nvidia.NVreg_PreserveVideoMemoryAllocations=1"` - For suspend/resume

### 3.3 Environment Variables
**System-wide environment variables:**
```nix
environment.sessionVariables = {
  # NVIDIA Wayland compatibility
  LIBVA_DRIVER_NAME = "nvidia";
  GBM_BACKEND = "nvidia-drm";
  __GLX_VENDOR_LIBRARY_NAME = "nvidia";
  
  # Wayland-specific
  WLR_NO_HARDWARE_CURSORS = "1";  # Fix cursor issues
  
  # NVIDIA-specific optimizations
  __GL_GSYNC_ALLOWED = "1";
  __GL_VRR_ALLOWED = "1";
};
```

### 3.4 Video Driver Configuration
```nix
services.xserver.videoDrivers = [ "nvidia" ];
```

### 3.5 Graphics Support
```nix
# Note: hardware.opengl was renamed to hardware.graphics in NixOS 24.05+
hardware.graphics = {
  enable = true;
  enable32Bit = true;  # For 32-bit applications (Steam, Wine)
};
```

**Important**: If you're using an older NixOS version (pre-24.05), use `hardware.opengl` instead of `hardware.graphics`.

### 3.6 GPU System Processor (GSP) for RTX Cards
```nix
# For RTX 20-series and newer cards, consider enabling GSP
hardware.nvidia.gsp.enable = true;  # Default varies by driver version
```

**Note**: GSP (GPU System Processor) offloads GPU initialization and management to the GPU firmware. This is becoming the default for newer drivers and RTX cards. Check NVIDIA documentation for your specific card.

### 3.7 Known Issues & Workarounds
- **Screen tearing**: `hardware.nvidia.forceFullCompositionPipeline = true;` (deprecated, not recommended for Wayland)
  - This option can reduce performance and cause issues with WebGL
  - Generally not needed with proper Wayland configuration
- **Suspend/Resume**: May require `nvidia.NVreg_PreserveVideoMemoryAllocations=1` kernel parameter
- **Black screen**: Ensure `nvidia-drm.modeset=1` is set in kernel parameters

---

## 4. Niri Compositor Setup

### 4.1 Niri Flake Integration
**Add to flake inputs:**
```nix
inputs.niri-flake = {
  url = "github:sodiboo/niri-flake";
  inputs.nixpkgs.follows = "nixpkgs";
};
```

**Import niri module:**
- Add `inputs.niri-flake.nixosModules.niri` to NixOS modules
- Add `inputs.niri-flake.homeManagerModules.niri` to home-manager modules

### 4.2 System-Level Niri Configuration
**In `modules/nixos/desktop.nix`:**
```nix
programs.niri.enable = true;
```

### 4.3 Required System Services for Wayland
**Essential services:**
- `services.greetd` or `services.sddm` - Display manager
  - greetd with tuigreet is lightweight for Wayland
  - Configure to auto-start niri session

- `security.polkit.enable = true;` - Authorization
- `services.dbus.enable = true;` - Inter-process communication
- `xdg.portal` configuration - Screen sharing, file pickers

### 4.4 XDG Desktop Portal Configuration
**Critical for Wayland functionality:**
```nix
xdg.portal = {
  enable = true;
  wlr.enable = true;  # wlroots-based portal for niri
  extraPortals = [
    pkgs.xdg-desktop-portal-gtk  # GTK file picker
  ];
  # Configure which portal to use for which interface
  config = {
    common = {
      default = [ "gtk" ];
    };
    niri = {
      default = [ "wlr" "gtk" ];
    };
  };
};
```

**Note**: The `xdg.portal.config` option specifies which portal backend provides each interface. The niri-flake may configure this automatically, but explicit configuration ensures correct behavior.

**Reference**: See [XDG Desktop Portal documentation](https://github.com/flatpak/xdg-desktop-portal/blob/main/doc/portals.conf.rst.in) for more details.

### 4.5 User-Level Niri Configuration
**In `home/<username>/niri.nix` (via home-manager):**
- Configure keybindings
- Set up workspaces
- Configure window rules
- Set wallpaper and appearance
- Configure outputs (monitors)

### 4.6 Niri Configuration File Location
- System: `/etc/niri/config.kdl`
- User: `~/.config/niri/config.kdl`
- Use home-manager to manage user config declaratively

---

## 5. Essential System Packages and Services

### 5.1 Core Wayland Packages
**Add to `environment.systemPackages`:**
- `pkgs.niri` - Compositor (if not using niri-flake)
- `pkgs.wayland`
- `pkgs.wayland-protocols`
- `pkgs.wayland-utils` - wayland-info, etc.

### 5.2 Terminal Emulator
Choose one (Wayland-native):
- `pkgs.foot` - Lightweight, fast
- `pkgs.alacritty` - GPU-accelerated
- `pkgs.kitty` - Feature-rich

### 5.3 Application Launcher
- `pkgs.fuzzel` - Wayland-native dmenu replacement
- `pkgs.wofi` - Alternative launcher
- `pkgs.rofi-wayland` - Rofi fork for Wayland

### 5.4 Status Bar / Panel
- `pkgs.waybar` - Highly customizable
- `pkgs.eww` - Widget system (more complex)

### 5.5 Notification Daemon
- `pkgs.mako` - Lightweight
- `pkgs.dunst` - Feature-rich (Wayland support)

### 5.6 Screen Locking
- `pkgs.swaylock` - Simple locker
- `pkgs.swaylock-effects` - With effects

### 5.7 Screenshot Tools
- `pkgs.grim` - Screenshot utility
- `pkgs.slurp` - Region selector
- `pkgs.swappy` - Screenshot editor

### 5.8 Clipboard Manager
- `pkgs.wl-clipboard` - CLI clipboard utilities
- `pkgs.cliphist` - Clipboard history

### 5.9 File Manager
- `pkgs.nautilus` - GNOME Files (GTK)
- `pkgs.thunar` - XFCE (lightweight)
- `pkgs.nnn` or `pkgs.ranger` - Terminal-based

### 5.10 Audio (PipeWire)
```nix
# Modern PipeWire configuration (NixOS 24.05+)
security.rtkit.enable = true;  # RealtimeKit for low-latency audio
services.pipewire = {
  enable = true;
  audio.enable = true;  # Use PipeWire as primary sound server
  # Legacy compatibility (automatically enabled by audio.enable in newer versions)
  alsa.enable = true;
  alsa.support32Bit = true;
  pulse.enable = true;  # PulseAudio compatibility
  jack.enable = true;   # Optional, for pro audio (JACK compatibility)
};
```

**Note**: `services.pipewire.audio.enable = true;` is the modern way to enable PipeWire as the primary sound server. It automatically configures ALSA and PulseAudio compatibility.

**Reference**: [NixOS PipeWire documentation](https://nixos.wiki/wiki/PipeWire)

### 5.11 Bluetooth (if needed)
```nix
hardware.bluetooth.enable = true;
services.blueman.enable = true;  # GUI manager
```

### 5.12 Network Management
```nix
networking.networkmanager.enable = true;
# Add user to networkmanager group
users.users.<username>.extraGroups = [ "networkmanager" ];
```

---

## 6. NVIDIA + Wayland + Niri Compatibility

### 6.1 Critical Compatibility Requirements
1. **Kernel modesetting MUST be enabled**
   - `hardware.nvidia.modesetting.enable = true;`
   - `boot.kernelParams = [ "nvidia-drm.modeset=1" ];`

2. **GBM backend configuration**
   - `GBM_BACKEND = "nvidia-drm";` environment variable

3. **Hardware cursor workaround**
   - `WLR_NO_HARDWARE_CURSORS = "1";` may be needed

### 6.2 Testing NVIDIA Wayland Support
**Commands to verify setup:**
```bash
# Check if nvidia-drm modesetting is active
cat /sys/module/nvidia_drm/parameters/modeset
# Should output: Y

# Check loaded NVIDIA modules
lsmod | grep nvidia

# Verify Wayland session
echo $XDG_SESSION_TYPE
# Should output: wayland

# Test EGL/GBM
eglinfo
```

### 6.3 Potential Issues and Solutions

**Issue: Black screen on boot**
- Solution: Add `nomodeset` temporarily, then configure NVIDIA properly

**Issue: Cursor not visible**
- Solution: Set `WLR_NO_HARDWARE_CURSORS = "1"`

**Issue: Screen tearing**
- Solution: Enable `hardware.nvidia.forceFullCompositionPipeline`

**Issue: Poor performance**
- Solution: Verify `__GLX_VENDOR_LIBRARY_NAME = "nvidia"` is set
- Check that `GBM_BACKEND = "nvidia-drm"` is set

**Issue: Applications crash**
- Solution: Ensure 32-bit graphics support is enabled
- Verify XDG portals are configured correctly

---

## 7. Recommended Directory Structure with Flat Import Pattern

### 7.1 Optimized Flat Structure
```
NixOS/
├── flake.nix                    # Entry point - ALL imports happen here
├── flake.lock                   # Auto-generated lock file
│
├── flake-parts/                 # Flake-parts modules (imported in flake.nix)
│   ├── packages.nix             # Custom package definitions
│   ├── overlays.nix             # Nixpkgs overlays
│   ├── devshells.nix            # Development environments
│   └── checks.nix               # Build checks (optional)
│
├── nixos/                       # NixOS system modules (flat, no nested imports)
│   ├── hardware.nix             # AMD Ryzen 7 5800X configuration
│   ├── nvidia.nix               # NVIDIA driver configuration
│   ├── desktop.nix              # Desktop environment (niri + XDG portals)
│   ├── boot.nix                 # Bootloader configuration
│   ├── networking.nix           # Network configuration
│   ├── locale.nix               # Locale, timezone, console
│   ├── users.nix                # User account definitions
│   ├── audio.nix                # PipeWire audio configuration
│   ├── packages.nix             # System-wide packages
│   └── nix-settings.nix         # Nix daemon, binary caches, gc
│
├── hosts/
│   └── <hostname>/              # Per-host configuration
│       ├── configuration.nix    # Host-specific settings (hostname, stateVersion)
│       └── hardware-configuration.nix  # Generated by nixos-generate-config
│
└── home/
    └── <username>/              # Per-user configuration (flat, no nested imports)
        ├── home.nix             # Home-manager base (username, homeDirectory)
        ├── niri.nix             # Niri user configuration
        ├── shell.nix            # Shell configuration (bash/zsh/fish)
        ├── git.nix              # Git configuration
        └── packages.nix         # User packages
```

### 7.2 Flat Import Pattern Principles

**Rule 1: Single Import Point**
- All NixOS module imports happen in `flake.nix` modules list
- All flake-parts module imports happen in `flake.nix` imports list
- Maximum import depth: 1 level (flake.nix → module)

**Rule 2: Self-Contained Modules**
- Each NixOS module file contains ONLY its own configuration
- No `imports = [ ... ]` statements within NixOS module files
- No dependencies between modules (except through NixOS module system options)

**Rule 3: Explicit Over Implicit**
- All loaded modules are visible in flake.nix
- Easy to see what's enabled/disabled
- No hidden configuration

**Rule 4: Granular Modules**
- Split large configurations into focused, single-purpose modules
- Each module handles one aspect (boot, networking, audio, etc.)
- Easier to enable/disable specific features

**Rule 5: Flake-Parts for Packages**
- Custom packages defined in flake-parts modules, not inline
- Overlays defined in flake-parts modules
- Development shells defined in flake-parts modules
- Keeps flake.nix clean and focused on structure

### 7.3 Benefits of Flat Import Pattern

**Advantages:**
- ✅ **Clarity**: All imports visible in one place
- ✅ **Simplicity**: No need to trace nested imports
- ✅ **Debugging**: Easier to identify problematic modules
- ✅ **Flexibility**: Simple to enable/disable features
- ✅ **Maintainability**: Clear dependency structure
- ✅ **Error Messages**: Better error reporting from Nix

**Comparison with Nested Imports:**
```nix
# ❌ Nested Pattern (harder to track)
modules = [
  ./hosts/myhost/default.nix  # This imports hardware.nix, nvidia.nix, etc.
];

# ✅ Flat Pattern (explicit and clear)
modules = [
  ./hosts/myhost/configuration.nix
  ./hosts/myhost/hardware-configuration.nix
  ./nixos/hardware.nix
  ./nixos/nvidia.nix
  ./nixos/desktop.nix
  # ... all modules listed explicitly
];
```

---

## 8. Implementation Steps (Execution Order)

### Phase 1: Foundation
1. Create directory structure (`nixos/`, `hosts/<hostname>/`, `home/<username>/`)
2. Write `flake.nix` with flake-parts and all module imports
3. Generate `hardware-configuration.nix` with `nixos-generate-config`
4. Create `hosts/<hostname>/configuration.nix` with hostname and stateVersion
5. Create basic modules: `nixos/boot.nix`, `nixos/networking.nix`, `nixos/locale.nix`

### Phase 2: Hardware & Drivers
6. Create `nixos/hardware.nix` with AMD CPU optimizations
7. Create `nixos/nvidia.nix` with NVIDIA drivers and Wayland support
8. Add all kernel parameters in respective modules
9. Configure environment variables in `nixos/nvidia.nix`

### Phase 3: Desktop Environment
10. Add niri-flake input to flake.nix
11. Create `nixos/desktop.nix` with niri and XDG portals
12. Configure display manager (greetd) in `nixos/desktop.nix`
13. Create `nixos/audio.nix` with PipeWire configuration
14. Create `nixos/packages.nix` with essential system packages

### Phase 4: User Environment
15. Create `nixos/users.nix` with user account definitions
16. Set up home-manager integration in flake.nix
17. Create `home/<username>/home.nix` with base configuration
18. Create `home/<username>/niri.nix` with niri user settings
19. Create `home/<username>/shell.nix`, `git.nix`, `packages.nix`
20. Import all home modules in flake.nix home-manager configuration

### Phase 5: Testing & Refinement
21. Build and test the configuration
22. Verify NVIDIA Wayland support
23. Test niri compositor functionality
24. Fine-tune performance and appearance
25. Document any host-specific customizations

---

## 9. Key NixOS Options Reference

### 9.1 Boot Configuration
- `boot.loader.systemd-boot.enable` or `boot.loader.grub.*`
- `boot.kernelPackages` - Kernel version selection
- `boot.kernelParams` - Kernel command-line parameters
- `boot.kernelModules` - Modules to load at boot

### 9.2 NVIDIA Options
- `hardware.nvidia.modesetting.enable`
- `hardware.nvidia.package`
- `hardware.nvidia.open`
- `hardware.nvidia.powerManagement.*`
- `services.xserver.videoDrivers`

### 9.3 Graphics Options
- `hardware.graphics.enable` (renamed from `hardware.opengl` in NixOS 24.05+)
- `hardware.graphics.enable32Bit`
- `hardware.graphics.extraPackages` - Additional graphics drivers (VA-API, VDPAU, etc.)

### 9.4 Desktop/Wayland Options
- `programs.niri.enable`
- `xdg.portal.*`
- `services.greetd.*` or `services.sddm.*`

### 9.5 Audio Options
- `services.pipewire.*`
- `security.rtkit.enable`

---

## 10. Additional Considerations

### 10.1 Home-Manager Integration
- **Standalone**: Separate home-manager activation
- **NixOS Module**: Integrated with system configuration
- Recommendation: Use NixOS module for simpler management

### 10.2 Niri Configuration Format
- Niri uses KDL (KDL Document Language) for configuration
- Can be managed via home-manager's `programs.niri.config` option
- Or use `home.file.".config/niri/config.kdl"` for raw config

### 10.3 Binary Cache
- Add niri-flake binary cache to speed up builds:
  ```nix
  nix.settings = {
    substituters = [ "https://niri.cachix.org" ];
    trusted-public-keys = [ "niri.cachix.org-1:Wv0OmO7PsuocRKzfDoJ3mulSl7Z6oezYhGhR+3W2964=" ];
  };
  ```

**Note**: The niri NixOS module automatically configures this binary cache unless you set `niri-flake.cache.enable = false;`. You can also add it manually with `cachix use niri`.

**Reference**: [niri-flake GitHub](https://github.com/sodiboo/niri-flake) - Binary cache is maintained by sodiboo

### 10.4 Backup and Rollback
- NixOS generations allow easy rollback
- Keep previous generations: `boot.loader.systemd-boot.configurationLimit = 10;`
- Test new configurations before committing

### 10.5 Documentation
- Document host-specific settings in host's `default.nix`
- Add comments for non-obvious configurations
- Keep a CHANGELOG or notes on major changes

---

## Summary

This plan provides a complete roadmap for setting up a NixOS system with:
- ✅ Flake-parts for modular organization
- ✅ AMD Ryzen 7 5800X optimizations
- ✅ NVIDIA drivers with full Wayland support
- ✅ Niri compositor as the desktop environment
- ✅ All necessary services and packages for a functional system

The modular structure allows for easy maintenance, testing, and extension. Each component is isolated in its own module, making it simple to enable/disable features or share configurations across multiple hosts.

